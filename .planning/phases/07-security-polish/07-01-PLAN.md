---
phase: 07-security-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/stores/authStore.ts
  - electron/main.js
  - electron/preload.js
  - frontend/src/components/auth/LoginModal.tsx
  - frontend/src/components/auth/SignupModal.tsx
  - frontend/src/components/auth/ForgotPasswordModal.tsx
  - frontend/src/components/auth/ResetPasswordView.tsx
autonomous: true

must_haves:
  truths:
    - "User receives email verification link after signup with correct deep link redirect"
    - "User can request password reset from login modal and receives email"
    - "User can set new password after clicking reset link in email"
    - "Deep link handler routes both email verification and password reset URLs to renderer"
    - "Auth error messages are user-friendly for email verification and reset flows"
  artifacts:
    - path: "frontend/src/stores/authStore.ts"
      provides: "requestPasswordReset, resetPassword, verifyEmail, resendVerification methods"
      contains: "requestPasswordReset"
    - path: "frontend/src/components/auth/ForgotPasswordModal.tsx"
      provides: "Forgot password request form with success state"
      contains: "resetPasswordForEmail"
    - path: "frontend/src/components/auth/ResetPasswordView.tsx"
      provides: "Set new password form loaded after reset deep link"
      contains: "updateUser"
    - path: "electron/main.js"
      provides: "Extended deep link handler for auth/confirm and auth/reset paths"
      contains: "auth-deep-link"
  key_links:
    - from: "electron/main.js handleOAuthCallback"
      to: "renderer via IPC"
      via: "auth-deep-link channel for email verify/reset, oauth-callback for OAuth"
      pattern: "send\\('auth-deep-link'"
    - from: "frontend/src/stores/authStore.ts"
      to: "electron preload onAuthDeepLink"
      via: "IPC listener in initialize()"
      pattern: "onAuthDeepLink"
    - from: "LoginModal.tsx"
      to: "ForgotPasswordModal.tsx"
      via: "openForgotPasswordModal() import"
      pattern: "openForgotPasswordModal"
---

<objective>
Implement email verification after signup and password reset flows with deep link handling.

Purpose: SEC-01 and SEC-02 requirements — users must verify email to use account, and can recover access via password reset email. Both flows use Electron deep links (extending existing OAuth infrastructure).

Output: Extended authStore with verification/reset methods, deep link handler for email links, ForgotPasswordModal, ResetPasswordView, and updated signup/login modals.
</objective>

<execution_context>
@/Users/damifiance/.claude/get-shit-done/workflows/execute-plan.md
@/Users/damifiance/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-security-polish/07-RESEARCH.md
@frontend/src/stores/authStore.ts
@frontend/src/components/auth/LoginModal.tsx
@frontend/src/components/auth/SignupModal.tsx
@electron/main.js
@electron/preload.js
@frontend/src/lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend auth infrastructure for email verification and password reset</name>
  <files>
    frontend/src/stores/authStore.ts
    electron/main.js
    electron/preload.js
  </files>
  <action>
**authStore.ts — Add new state and methods to AuthState interface and store:**

1. Add state fields:
   - `pendingVerification: string | null` — email awaiting verification (set after signup)
   - `resetPasswordMode: boolean` — true when user arrived via reset deep link

2. Add method: `requestPasswordReset(email: string) => Promise<{ error?: string }>`:
   - Calls `supabase.auth.resetPasswordForEmail(email, { redirectTo: isElectron ? 'lumenai://auth/reset' : window.location.origin + '/auth/reset' })`
   - Sets isLoading during call, translates errors via translateAuthError

3. Add method: `resetPassword(newPassword: string) => Promise<{ error?: string }>`:
   - Calls `supabase.auth.updateUser({ password: newPassword })`
   - On success sets `resetPasswordMode: false`
   - IMPORTANT: This only works when session exists (created by reset link click)

4. Add method: `verifyEmail(tokenHash: string) => Promise<{ error?: string }>`:
   - Calls `supabase.auth.verifyOtp({ token_hash: tokenHash, type: 'email' })`
   - On success sets `pendingVerification: null`

5. Add method: `resendVerification(email: string) => Promise<{ error?: string }>`:
   - Calls `supabase.auth.resend({ type: 'signup', email, options: { emailRedirectTo: isElectron ? 'lumenai://auth/confirm' : window.location.origin + '/auth/confirm' } })`

6. Update existing `signUp` method:
   - Pass `options: { emailRedirectTo: isElectron ? 'lumenai://auth/confirm' : window.location.origin + '/auth/confirm' }` to signUp call
   - On success, set `pendingVerification: email`

7. Add to `initialize()` — register IPC listener for auth deep links (alongside existing OAuth listener):
   ```
   if (window.electron?.onAuthDeepLink) {
     window.electron.onAuthDeepLink(async ({ tokenHash, type }) => {
       if (type === 'email') {
         // Email verification
         await get().verifyEmail(tokenHash);
       } else if (type === 'recovery') {
         // Password reset — exchange token for session, then show reset form
         const { error } = await supabase.auth.verifyOtp({ token_hash: tokenHash, type: 'recovery' });
         if (!error) {
           set({ resetPasswordMode: true });
         }
       }
     });
   }
   ```

8. Extend `translateAuthError` with new cases:
   - `'otp_expired'` → 'This link has expired. Please request a new one.'
   - `'same_password'` → 'New password must be different from your current password.'

**electron/main.js — Extend deep link handler:**

Rename `handleOAuthCallback` to `handleDeepLink` (or keep and extend). The existing function parses `lumenai://` URLs. Update it to handle THREE paths:

- `lumenai://auth/callback?code=...` — existing OAuth callback (keep as-is, sends 'oauth-callback')
- `lumenai://auth/confirm?token_hash=...&type=email` — email verification (NEW, sends 'auth-deep-link')
- `lumenai://auth/reset?token_hash=...&type=recovery` — password reset (NEW, sends 'auth-deep-link')

Implementation: After parsing URL, check pathname:
```javascript
const urlObj = new URL(url);
const pathname = urlObj.pathname; // '/auth/callback', '/auth/confirm', '/auth/reset'

if (pathname === '/auth/callback') {
  // Existing OAuth flow — keep current code
} else if (pathname === '/auth/confirm' || pathname === '/auth/reset') {
  const tokenHash = urlObj.searchParams.get('token_hash');
  const type = urlObj.searchParams.get('type');
  const payload = { tokenHash, type };
  if (mainWindow?.webContents) {
    mainWindow.webContents.send('auth-deep-link', payload);
  } else {
    pendingAuthDeepLink = payload; // Add new variable for pending deep links
  }
}
```

Also add `pendingAuthDeepLink` handling in `did-finish-load` (same pattern as pendingOAuthUrl).

Update all references from `handleOAuthCallback` to `handleDeepLink` in: `second-instance`, `open-url`, and argv parsing.

**electron/preload.js — Add auth deep link IPC:**

Add to the contextBridge.exposeInMainWorld object:
```javascript
onAuthDeepLink: (callback) => ipcRenderer.on('auth-deep-link', (_event, data) => callback(data)),
removeAuthDeepLink: () => ipcRenderer.removeAllListeners('auth-deep-link'),
```
  </action>
  <verify>
    - `grep -r "requestPasswordReset\|resetPassword\|verifyEmail\|resendVerification" frontend/src/stores/authStore.ts` returns all 4 methods
    - `grep -r "auth-deep-link" electron/main.js electron/preload.js` shows IPC channel wired in both files
    - `grep "emailRedirectTo" frontend/src/stores/authStore.ts` shows redirect URL in signUp
    - `grep "pendingAuthDeepLink" electron/main.js` shows pending deep link handling
    - TypeScript compilation passes: `npx tsc --noEmit` (from frontend/)
  </verify>
  <done>
    - authStore has requestPasswordReset, resetPassword, verifyEmail, resendVerification methods
    - signUp passes emailRedirectTo for deep link verification
    - Electron deep link handler routes email confirm and reset URLs to renderer via 'auth-deep-link' IPC
    - preload.js exposes onAuthDeepLink bridge
    - Pending deep link is buffered for cold start scenario
    - New auth error codes translated to user-friendly messages
  </done>
</task>

<task type="auto">
  <name>Task 2: Create password reset UI and update auth modals</name>
  <files>
    frontend/src/components/auth/ForgotPasswordModal.tsx
    frontend/src/components/auth/ResetPasswordView.tsx
    frontend/src/components/auth/LoginModal.tsx
    frontend/src/components/auth/SignupModal.tsx
  </files>
  <action>
**ForgotPasswordModal.tsx — New file, module-level listener pattern (matching LoginModal/SignupModal):**

Structure:
- Module-level `_listener` + `openForgotPasswordModal()` export
- Two states: form state (email input) and success state ("Check your email")
- Form calls `useAuthStore().requestPasswordReset(email)`
- Success state shows email sent confirmation with "Back to Login" button
- Loading states with Loader2 spinner (matching existing modal style)
- Same visual styling as LoginModal (rounded-2xl, shadow-2xl, px-6, etc.)
- X close button in header
- Import lucide icons: Mail, X, Loader2, CheckCircle

**ResetPasswordView.tsx — New file, inline component (not a modal):**

This is NOT a modal — it's a view that replaces the main app content when `resetPasswordMode` is true.
- Reads `resetPasswordMode` from useAuthStore
- If `resetPasswordMode === false`, returns null
- Shows centered form with: new password input, confirm password input, submit button
- Validates passwords match before submitting
- Calls `useAuthStore().resetPassword(newPassword)`
- On success, shows brief "Password updated!" message then clears resetPasswordMode (user sees main app)
- On error, shows error message with "Request new link" button (calls requestPasswordReset + switches to success state)
- Styling: centered on page, max-w-md, consistent with existing auth UI

**LoginModal.tsx — Add "Forgot password?" link:**

Add between the password field and submit button:
```tsx
<div className="flex justify-end mb-4">
  <button
    type="button"
    onClick={handleForgotPassword}
    className="text-xs text-gray-400 hover:text-accent cursor-pointer"
  >
    Forgot password?
  </button>
</div>
```

Add `handleForgotPassword` function:
```tsx
const handleForgotPassword = async () => {
  handleClose();
  const { openForgotPasswordModal } = await import('./ForgotPasswordModal');
  openForgotPasswordModal();
};
```

Also handle `email_not_confirmed` error in login: when this error occurs, show a message with "Resend verification email" button that calls `useAuthStore().resendVerification(email)`.

**SignupModal.tsx — Enhance success state with resend functionality:**

In the success state (isSuccess section), add a resend button:
```tsx
const [resending, setResending] = useState(false);
const [resent, setResent] = useState(false);

const handleResend = async () => {
  setResending(true);
  await resendVerification(email);
  setResending(false);
  setResent(true);
};
```

Add below the existing "Check your email" text:
```tsx
<button
  onClick={handleResend}
  disabled={resending || resent}
  className="text-sm text-accent hover:text-accent-hover cursor-pointer disabled:text-gray-300 disabled:cursor-not-allowed"
>
  {resent ? 'Email sent!' : resending ? 'Sending...' : 'Resend confirmation email'}
</button>
```

**App integration — Render ResetPasswordView at app level:**

The ResetPasswordView must be rendered somewhere at the app level (e.g., in App.tsx or the main layout). It conditionally renders when `resetPasswordMode` is true, overlaying the app content. Check where LoginModal/SignupModal are rendered and add ResetPasswordView alongside them. Also render ForgotPasswordModal there.
  </action>
  <verify>
    - ForgotPasswordModal.tsx exists and exports `openForgotPasswordModal`
    - ResetPasswordView.tsx exists and reads `resetPasswordMode` from authStore
    - `grep "Forgot password" frontend/src/components/auth/LoginModal.tsx` shows the link
    - `grep "Resend" frontend/src/components/auth/SignupModal.tsx` shows resend button
    - `grep "ForgotPasswordModal\|ResetPasswordView" frontend/src/App.tsx` (or equivalent) shows both rendered
    - TypeScript compilation passes: `npx tsc --noEmit` (from frontend/)
  </verify>
  <done>
    - ForgotPasswordModal opens from LoginModal "Forgot password?" link
    - User can enter email and receive password reset email
    - ResetPasswordView shows when user clicks reset link in email (deep link sets resetPasswordMode)
    - User can enter and confirm new password
    - SignupModal success state has "Resend confirmation email" button
    - LoginModal shows helpful message when email_not_confirmed error occurs
    - All new components rendered at app level
  </done>
</task>

</tasks>

<verification>
1. Email verification flow: signup -> "check email" message -> resend works -> deep link would route correctly (Electron IPC wired)
2. Password reset flow: login -> forgot password -> enter email -> "check email" -> deep link routes to ResetPasswordView -> new password saved
3. Auth error messages are user-friendly for all new error codes
4. All components follow existing modal/UI patterns (module-level listener, Tailwind styling)
5. TypeScript compiles without errors
</verification>

<success_criteria>
- authStore has 4 new methods: requestPasswordReset, resetPassword, verifyEmail, resendVerification
- signUp passes emailRedirectTo for deep link
- Electron deep link handler routes email verify/reset URLs alongside OAuth
- ForgotPasswordModal accessible from LoginModal
- ResetPasswordView renders after reset deep link
- SignupModal has resend verification button
- All components consistent with existing auth UI design
</success_criteria>

<output>
After completion, create `.planning/phases/07-security-polish/07-01-SUMMARY.md`
</output>
