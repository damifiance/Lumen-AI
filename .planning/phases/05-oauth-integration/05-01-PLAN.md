---
phase: 05-oauth-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - electron/main.js
  - electron/preload.js
  - electron/electron-builder.json
  - frontend/src/electron.d.ts
  - frontend/src/stores/authStore.ts
  - frontend/src/lib/supabase.ts
autonomous: true

must_haves:
  truths:
    - "Electron registers lumenai:// custom protocol on startup"
    - "OAuth callback URL from browser is received by Electron main process"
    - "Auth code from callback is forwarded to renderer via IPC"
    - "Renderer exchanges auth code for Supabase session"
    - "OAuth works on cold start (app not running) and warm handoff (app running)"
  artifacts:
    - path: "electron/main.js"
      provides: "Protocol handler registration, open-url + second-instance listeners, handleOAuthCallback, openExternal IPC"
      contains: "setAsDefaultProtocolClient"
    - path: "electron/preload.js"
      provides: "startOAuth and onOAuthCallback IPC bridges"
      contains: "oauth-callback"
    - path: "electron/electron-builder.json"
      provides: "Protocol registration for packaged builds"
      contains: "lumenai"
    - path: "frontend/src/stores/authStore.ts"
      provides: "signInWithOAuth method, OAuth callback listener setup"
      exports: ["useAuthStore"]
    - path: "frontend/src/lib/supabase.ts"
      provides: "Supabase client with flowType pkce"
      contains: "flowType"
    - path: "frontend/src/electron.d.ts"
      provides: "TypeScript types for new IPC methods"
      contains: "startOAuth"
  key_links:
    - from: "electron/main.js"
      to: "electron/preload.js"
      via: "IPC channels: start-oauth, open-external-url, oauth-callback"
      pattern: "ipcMain\\.handle\\('start-oauth'"
    - from: "electron/preload.js"
      to: "frontend/src/stores/authStore.ts"
      via: "window.electron.startOAuth and window.electron.onOAuthCallback"
      pattern: "window\\.electron\\."
    - from: "frontend/src/stores/authStore.ts"
      to: "frontend/src/lib/supabase.ts"
      via: "supabase.auth.signInWithOAuth + exchangeCodeForSession"
      pattern: "exchangeCodeForSession"

user_setup:
  - service: supabase-google-oauth
    why: "Google OAuth provider must be configured in Supabase Dashboard"
    env_vars: []
    dashboard_config:
      - task: "Enable Google provider in Authentication > Providers > Google"
        location: "Supabase Dashboard > Authentication > Providers"
      - task: "Add Google OAuth Client ID and Secret from Google Cloud Console"
        location: "Google Cloud Console > APIs & Services > Credentials > OAuth 2.0 Client IDs"
      - task: "Add lumenai://auth/callback to Supabase Redirect URLs"
        location: "Supabase Dashboard > Authentication > URL Configuration > Redirect URLs"
  - service: supabase-github-oauth
    why: "GitHub OAuth provider must be configured in Supabase Dashboard"
    env_vars: []
    dashboard_config:
      - task: "Enable GitHub provider in Authentication > Providers > GitHub"
        location: "Supabase Dashboard > Authentication > Providers"
      - task: "Create GitHub OAuth App with callback URL from Supabase"
        location: "GitHub Settings > Developer Settings > OAuth Apps > New"
      - task: "Add Client ID and Secret to Supabase GitHub provider config"
        location: "Supabase Dashboard > Authentication > Providers > GitHub"
---

<objective>
Wire up Electron custom protocol handler (lumenai://) for OAuth deep linking, add IPC bridge for OAuth flow, and implement signInWithOAuth in the auth store with callback handling.

Purpose: This is the plumbing that makes OAuth work in Electron — protocol registration, platform-specific deep link handling, and the frontend OAuth exchange logic. Without this, clicking "Sign in with Google/GitHub" has nowhere to redirect back to.

Output: Complete OAuth flow infrastructure (Electron + frontend) ready for UI buttons in Plan 02.
</objective>

<execution_context>
@/Users/damifiance/.claude/get-shit-done/workflows/execute-plan.md
@/Users/damifiance/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-oauth-integration/05-RESEARCH.md
@electron/main.js
@electron/preload.js
@electron/secureStore.js
@electron/electron-builder.json
@frontend/src/stores/authStore.ts
@frontend/src/lib/supabase.ts
@frontend/src/lib/secureStorage.ts
@frontend/src/electron.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Electron protocol handler + deep link listeners + OAuth IPC</name>
  <files>electron/main.js, electron/preload.js, electron/electron-builder.json</files>
  <action>
**electron/main.js** — Add the following BEFORE `app.whenReady()`:

1. Register custom protocol handler:
   ```
   if (process.defaultApp) {
     if (process.argv.length >= 2) {
       app.setAsDefaultProtocolClient('lumenai', process.execPath, [path.resolve(process.argv[1])]);
     }
   } else {
     app.setAsDefaultProtocolClient('lumenai');
   }
   ```

2. Add single instance lock with second-instance handler (Windows/Linux deep links):
   ```
   const gotTheLock = app.requestSingleInstanceLock();
   if (!gotTheLock) {
     app.quit();
   } else {
     app.on('second-instance', (event, commandLine) => {
       const url = commandLine.find((arg) => arg.startsWith('lumenai://'));
       if (url) handleOAuthCallback(url);
       if (mainWindow) {
         if (mainWindow.isMinimized()) mainWindow.restore();
         mainWindow.focus();
       }
     });
   }
   ```

3. Add macOS open-url handler (handles both cold start and warm handoff):
   ```
   app.on('open-url', (event, url) => {
     event.preventDefault();
     handleOAuthCallback(url);
   });
   ```

4. Add `handleOAuthCallback` function that parses the URL, extracts `code` and `error` params, and sends to renderer via `mainWindow.webContents.send('oauth-callback', { code, error })`. If mainWindow doesn't exist yet (cold start), store the URL in a variable (`pendingOAuthUrl`) and process it after window creation. In the `createWindow` function, after `mainWindow.webContents.on('did-finish-load', ...)` check for pendingOAuthUrl and send it.

5. Inside `app.whenReady()`, after existing IPC handlers, add:
   - `ipcMain.handle('start-oauth', async (_event, url) => { const { shell } = require('electron'); shell.openExternal(url); })` — renderer generates the Supabase OAuth URL and sends it to main to open in external browser.

6. Cold start check for Windows/Linux: Inside `app.whenReady()`, after creating the window, check `process.argv` for a `lumenai://` URL and call `handleOAuthCallback` if found.

**electron/preload.js** — Add to the `contextBridge.exposeInMainWorld('electron', {...})` object:
- `startOAuth: (url) => ipcRenderer.invoke('start-oauth', url)` — opens OAuth URL in external browser
- `onOAuthCallback: (callback) => ipcRenderer.on('oauth-callback', (_event, data) => callback(data))` — listens for OAuth callback from main process
- `removeOAuthCallback: () => ipcRenderer.removeAllListeners('oauth-callback')` — cleanup

**electron/electron-builder.json** — Add `protocols` field at the top level:
```json
"protocols": {
  "name": "Lumen AI OAuth",
  "schemes": ["lumenai"]
}
```
Also add `"auth.js"` is NOT needed (no separate file — logic stays in main.js to keep it simple and access `mainWindow` directly).

  </action>
  <verify>
Run `node -e "require('./electron/main.js')" 2>&1 || true` to check for syntax errors (will fail on Electron APIs but should not show JS syntax errors). Manually verify electron-builder.json is valid JSON with `node -e "JSON.parse(require('fs').readFileSync('electron/electron-builder.json', 'utf8'))"`. Check preload.js for syntax with `node -e "require('./electron/preload.js')" 2>&1 || true`.
  </verify>
  <done>
electron/main.js has: setAsDefaultProtocolClient('lumenai'), single instance lock with second-instance handler, open-url handler, handleOAuthCallback function, pendingOAuthUrl for cold start, start-oauth IPC handler. electron/preload.js exposes startOAuth, onOAuthCallback, removeOAuthCallback. electron-builder.json has protocols field with lumenai scheme.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend OAuth store methods + callback listener + type definitions</name>
  <files>frontend/src/stores/authStore.ts, frontend/src/lib/supabase.ts, frontend/src/electron.d.ts</files>
  <action>
**frontend/src/electron.d.ts** — Add to the `window.electron` interface:
- `startOAuth: (url: string) => Promise<void>` — opens OAuth URL in external browser
- `onOAuthCallback: (callback: (data: { code?: string; error?: string }) => void) => void` — listens for OAuth callback
- `removeOAuthCallback: () => void` — cleanup listener

**frontend/src/lib/supabase.ts** — Update the Supabase client config to include PKCE flow type:
- Add `flowType: 'pkce'` to the `auth` options object. This tells Supabase to use PKCE for OAuth flows.
- Keep `detectSessionInUrl: false` (Electron handles the URL, not the browser).

**frontend/src/stores/authStore.ts** — Add to the interface and implementation:

1. Add `signInWithOAuth: (provider: 'google' | 'github') => Promise<void>` to the AuthState interface.

2. Implement `signInWithOAuth`:
   ```
   signInWithOAuth: async (provider) => {
     set({ isLoading: true, error: null });
     try {
       const isElectron = window.electron != null;

       if (isElectron) {
         // Generate OAuth URL with Supabase (skipBrowserRedirect = true)
         const { data, error } = await supabase.auth.signInWithOAuth({
           provider,
           options: {
             redirectTo: 'lumenai://auth/callback',
             skipBrowserRedirect: true,
           },
         });
         if (error) throw error;
         // Open in external browser via Electron main process
         await window.electron!.startOAuth(data.url);
       } else {
         // Web mode: use default Supabase redirect behavior
         const { error } = await supabase.auth.signInWithOAuth({
           provider,
           options: {
             redirectTo: `${window.location.origin}/auth/callback`,
           },
         });
         if (error) throw error;
       }
       set({ isLoading: false });
     } catch (err) {
       const translated = translateAuthError(err);
       set({ error: translated, isLoading: false });
     }
   }
   ```

3. In the `initialize` function, after the `onAuthStateChange` listener setup, add OAuth callback listener for Electron:
   ```
   // Listen for OAuth callbacks from Electron main process
   if (window.electron?.onOAuthCallback) {
     window.electron.onOAuthCallback(async ({ code, error: oauthError }) => {
       if (oauthError) {
         set({ error: `OAuth failed: ${oauthError}`, isLoading: false });
         return;
       }
       if (code) {
         try {
           const { error } = await supabase.auth.exchangeCodeForSession(code);
           if (error) throw error;
           // Session update will be handled by onAuthStateChange
         } catch (err) {
           set({ error: translateAuthError(err), isLoading: false });
         }
       }
     });
   }
   ```
   Note: This is safe because `exchangeCodeForSession` is NOT called inside `onAuthStateChange` — it's in a separate IPC callback. The `onAuthStateChange` listener will pick up the session change automatically.

  </action>
  <verify>
Run `cd /Users/damifiance/workspace/AI-paper-reader/frontend && npx tsc --noEmit 2>&1 | head -30` to check for TypeScript errors. Verify authStore has `signInWithOAuth` method and `exchangeCodeForSession` call.
  </verify>
  <done>
authStore.ts has signInWithOAuth method supporting google and github providers. In Electron mode, generates OAuth URL with skipBrowserRedirect, opens in external browser via IPC. OAuth callback listener in initialize() receives auth code from main process and exchanges for session via supabase.auth.exchangeCodeForSession(). supabase.ts has flowType: 'pkce'. electron.d.ts has types for startOAuth, onOAuthCallback, removeOAuthCallback.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `cd frontend && npx tsc --noEmit`
2. electron-builder.json is valid JSON with `protocols.schemes` containing `"lumenai"`
3. electron/main.js has `setAsDefaultProtocolClient('lumenai')` call
4. electron/preload.js exposes `startOAuth`, `onOAuthCallback`, `removeOAuthCallback`
5. authStore.ts exports `signInWithOAuth` method
6. supabase.ts includes `flowType: 'pkce'`
</verification>

<success_criteria>
- Electron registers lumenai:// protocol on app startup
- Deep link callbacks handled on all platforms (macOS open-url, Windows/Linux second-instance + cold start argv)
- OAuth URL opened in external browser via shell.openExternal
- Auth code from callback forwarded to renderer via IPC
- Renderer exchanges code for Supabase session via PKCE
- Cold start scenario handled (pendingOAuthUrl stored until window ready)
- All TypeScript types correct
</success_criteria>

<output>
After completion, create `.planning/phases/05-oauth-integration/05-01-SUMMARY.md`
</output>
