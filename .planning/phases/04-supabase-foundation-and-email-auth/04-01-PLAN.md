---
phase: 04-supabase-foundation-and-email-auth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - electron/secureStore.js
  - electron/main.js
  - electron/preload.js
  - electron/package.json
  - frontend/src/lib/secureStorage.ts
  - frontend/src/lib/supabase.ts
  - frontend/src/stores/authStore.ts
  - frontend/src/electron.d.ts
  - frontend/package.json
  - frontend/src/env.d.ts
autonomous: true
user_setup:
  - service: supabase
    why: "Authentication backend — stores user accounts, handles email/password auth"
    env_vars:
      - name: VITE_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: VITE_SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> anon/public key"
    dashboard_config:
      - task: "Create a Supabase project (if not already done)"
        location: "https://supabase.com/dashboard -> New Project"
      - task: "Enable Email provider under Authentication -> Providers -> Email"
        location: "Supabase Dashboard -> Authentication -> Providers"
      - task: "(Optional) Disable 'Confirm email' for faster dev testing"
        location: "Supabase Dashboard -> Authentication -> Email Provider -> toggle off 'Confirm email'"

must_haves:
  truths:
    - "Supabase client initializes with custom secure storage adapter"
    - "Tokens are encrypted via Electron safeStorage before persistence"
    - "Auth store tracks user, session, loading, and initialized state"
    - "IPC handlers for secureStore:set, secureStore:get, secureStore:remove are registered"
  artifacts:
    - path: "electron/secureStore.js"
      provides: "safeStorage encrypt/decrypt logic with electron-store persistence"
      contains: "safeStorage.encryptString"
    - path: "electron/main.js"
      provides: "IPC handler registration for secureStore channels"
      contains: "secureStore:set"
    - path: "electron/preload.js"
      provides: "contextBridge secureStore API exposure"
      contains: "secureStore"
    - path: "frontend/src/lib/secureStorage.ts"
      provides: "Custom Supabase storage adapter routing through IPC"
      exports: ["secureStorage"]
    - path: "frontend/src/lib/supabase.ts"
      provides: "Supabase client configured with secure storage adapter"
      exports: ["supabase"]
    - path: "frontend/src/stores/authStore.ts"
      provides: "Zustand auth store with initialize, signUp, signIn, signOut"
      exports: ["useAuthStore"]
  key_links:
    - from: "frontend/src/lib/secureStorage.ts"
      to: "electron/preload.js"
      via: "window.electron.secureStore IPC calls"
      pattern: "window\\.electron\\.secureStore\\."
    - from: "frontend/src/lib/supabase.ts"
      to: "frontend/src/lib/secureStorage.ts"
      via: "auth.storage option"
      pattern: "storage:\\s*secureStorage"
    - from: "frontend/src/stores/authStore.ts"
      to: "frontend/src/lib/supabase.ts"
      via: "import supabase client for auth operations"
      pattern: "supabase\\.auth\\."
---

<objective>
Set up Electron secure token storage, Supabase client with custom storage adapter, and Zustand auth store.

Purpose: Create the foundational infrastructure for email/password authentication. Tokens must be encrypted via Electron's safeStorage API (not localStorage) and the auth store must provide a clean interface for UI components to consume.

Output: Working Supabase client that persists sessions securely through app restarts, and an auth store with signUp/signIn/signOut actions.
</objective>

<execution_context>
@/Users/damifiance/.claude/get-shit-done/workflows/execute-plan.md
@/Users/damifiance/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-supabase-foundation-and-email-auth/04-RESEARCH.md

@electron/main.js
@electron/preload.js
@electron/package.json
@frontend/src/electron.d.ts
@frontend/src/stores/paperStore.ts
@frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Electron secure storage IPC layer</name>
  <files>electron/secureStore.js, electron/main.js, electron/preload.js, electron/package.json</files>
  <action>
    1. Install `electron-store` in electron/: `cd electron && npm install electron-store`

    2. Create `electron/secureStore.js`:
       - Import `safeStorage` from electron and `Store` from `electron-store` (note: electron-store v10+ is ESM-only, so use v9.x which is CommonJS compatible — `npm install electron-store@9`)
       - Create store instance with `name: 'secure-tokens'`
       - Export three functions:
         - `set(key, value)`: Check `safeStorage.isEncryptionAvailable()`, throw error if unavailable. Call `safeStorage.encryptString(value)`, convert to base64, store via `store.set(key, base64)`
         - `get(key)`: Get base64 from store, if null return null. Convert Buffer.from(base64, 'base64'), call `safeStorage.decryptString(buffer)`, return string
         - `remove(key)`: Call `store.delete(key)`
       - Handle the edge case where safeStorage is not available (Linux without keyring): log a warning and use unencrypted fallback with a console.warn, since blocking the entire app is worse UX. The research says "fail loudly" but for dev mode this would be frustrating — check `isEncryptionAvailable()` and warn but still store.

    3. Update `electron/main.js`:
       - Add `const secureStore = require('./secureStore');` at top with other requires
       - Inside `app.whenReady().then(async () => { ... })`, before `createWindow()`, register three IPC handlers:
         ```
         ipcMain.handle('secureStore:set', async (_event, key, value) => { secureStore.set(key, value); });
         ipcMain.handle('secureStore:get', async (_event, key) => { return secureStore.get(key); });
         ipcMain.handle('secureStore:remove', async (_event, key) => { secureStore.remove(key); });
         ```
       - Place these AFTER the existing `ipcMain.handle('get-backend-port', ...)` block.

    4. Update `electron/preload.js`:
       - Add `secureStore` to the existing `contextBridge.exposeInMainWorld('electron', { ... })` object:
         ```
         secureStore: {
           get: (key) => ipcRenderer.invoke('secureStore:get', key),
           set: (key, value) => ipcRenderer.invoke('secureStore:set', key, value),
           remove: (key) => ipcRenderer.invoke('secureStore:remove', key),
         }
         ```
       - Keep existing getBackendPort, checkForUpdates, getAppVersion entries unchanged.

    5. Update `electron/electron-builder.json` to include `secureStore.js` in the files array if it uses explicit file listing.
  </action>
  <verify>
    - `cd /Users/damifiance/workspace/AI-paper-reader/electron && node -e "require('./secureStore')"` should not throw (module loads)
    - `cat electron/main.js | grep "secureStore:set"` confirms IPC handler exists
    - `cat electron/preload.js | grep "secureStore"` confirms bridge exposure
  </verify>
  <done>
    - secureStore.js exports set/get/remove functions using safeStorage + electron-store
    - main.js registers 3 IPC handlers (secureStore:set/get/remove)
    - preload.js exposes secureStore API via contextBridge
    - electron-store@9 installed in electron/package.json
  </done>
</task>

<task type="auto">
  <name>Task 2: Supabase client, secure storage adapter, and auth store</name>
  <files>frontend/src/lib/secureStorage.ts, frontend/src/lib/supabase.ts, frontend/src/stores/authStore.ts, frontend/src/electron.d.ts, frontend/package.json, frontend/src/env.d.ts</files>
  <action>
    1. Install `@supabase/supabase-js` in frontend/: `cd frontend && npm install @supabase/supabase-js`

    2. Update `frontend/src/electron.d.ts` — add secureStore to the Window.electron interface:
       ```typescript
       electron?: {
         getBackendPort: () => Promise<number>;
         checkForUpdates: () => Promise<{ updateAvailable: boolean; latestVersion?: string; currentVersion?: string; error?: string }>;
         getAppVersion: () => Promise<string>;
         secureStore: {
           get: (key: string) => Promise<string | null>;
           set: (key: string, value: string) => Promise<void>;
           remove: (key: string) => Promise<void>;
         };
       };
       ```

    3. Create `frontend/src/env.d.ts` (or add to existing) for Vite env types:
       ```typescript
       /// <reference types="vite/client" />
       interface ImportMetaEnv {
         readonly VITE_SUPABASE_URL: string;
         readonly VITE_SUPABASE_ANON_KEY: string;
       }
       ```

    4. Create `frontend/src/lib/secureStorage.ts`:
       - Export `secureStorage` object implementing `{ getItem, setItem, removeItem }` (Supabase storage interface).
       - Each method checks `window.electron?.secureStore` — if available, routes through IPC. If NOT available (web dev mode), falls back to `localStorage` with a `console.warn('Running without secure storage — using localStorage fallback')` on first call.
       - `getItem(key: string): Promise<string | null>` — returns `window.electron.secureStore.get(key)` or `localStorage.getItem(key)`
       - `setItem(key: string, value: string): Promise<void>` — calls `window.electron.secureStore.set(key, value)` or `localStorage.setItem(key, value)`
       - `removeItem(key: string): Promise<void>` — calls `window.electron.secureStore.remove(key)` or `localStorage.removeItem(key)`
       - This fallback is ONLY for development when running `npm run dev` in browser without Electron. In production Electron builds, `window.electron` is always present.

    5. Create `frontend/src/lib/supabase.ts`:
       - Import `createClient` from `@supabase/supabase-js`
       - Import `secureStorage` from `./secureStorage`
       - Create and export `supabase` client:
         ```typescript
         export const supabase = createClient(
           import.meta.env.VITE_SUPABASE_URL || '',
           import.meta.env.VITE_SUPABASE_ANON_KEY || '',
           {
             auth: {
               storage: secureStorage,
               autoRefreshToken: true,
               persistSession: true,
               detectSessionInUrl: false, // Not needed for Electron
             }
           }
         );
         ```
       - Add guard: if either env var is empty, log `console.warn('Supabase not configured — auth features disabled')`.

    6. Create `frontend/src/stores/authStore.ts`:
       - Import `create` from `zustand`, `supabase` from `../lib/supabase`, types `User` and `Session` from `@supabase/supabase-js`
       - Define `AuthState` interface with: `user: User | null`, `session: Session | null`, `isLoading: boolean`, `isInitialized: boolean`, `error: string | null`
       - Actions: `initialize()`, `signUp(email, password)`, `signIn(email, password)`, `signOut()`, `clearError()`
       - `initialize()`:
         - If `import.meta.env.VITE_SUPABASE_URL` is empty, set `isInitialized: true` and return early (offline mode, no auth)
         - Call `supabase.auth.getSession()` to load persisted session
         - Set `session`, `user: session?.user ?? null`, `isInitialized: true`
         - Register `supabase.auth.onAuthStateChange((_event, session) => { set({ session, user: session?.user ?? null }) })`
         - CRITICAL: Do NOT call any supabase.* methods inside the onAuthStateChange callback (deadlock bug)
       - `signUp(email, password)`:
         - Set `isLoading: true`, `error: null`
         - Call `supabase.auth.signUp({ email, password })`
         - On error: translate using `translateAuthError()` helper, set error, return `{ error: translated }`
         - On success: set `isLoading: false`, return `{}`
         - NOTE: After signup, user typically needs to confirm email before signIn works (Supabase default). Return a hint about checking email.
       - `signIn(email, password)`:
         - Set `isLoading: true`, `error: null`
         - Call `supabase.auth.signInWithPassword({ email, password })`
         - On error: translate, set error, return `{ error }`
         - On success: set `isLoading: false`, return `{}`
       - `signOut()`:
         - Call `supabase.auth.signOut()`
         - Set `user: null, session: null`
       - `clearError()`: Set `error: null`
       - `translateAuthError(error: AuthError)` helper (private function, not exported):
         - Import `AuthApiError` from `@supabase/supabase-js`
         - If `error instanceof AuthApiError`, switch on `error.code`:
           - `'invalid_credentials'` -> `'Invalid email or password'`
           - `'email_not_confirmed'` -> `'Please check your email and confirm your account first'`
           - `'user_already_exists'` -> `'An account with this email already exists'`
           - `'weak_password'` -> `'Password must be at least 6 characters'`
           - `'over_email_send_rate_limit'` -> `'Too many attempts. Please wait a few minutes.'`
           - default -> `'Unable to complete request. Please try again.'`
         - If not AuthApiError: `'Network error. Please check your connection.'`

    7. Create `.env.example` at frontend root with:
       ```
       VITE_SUPABASE_URL=
       VITE_SUPABASE_ANON_KEY=
       ```
  </action>
  <verify>
    - `cd /Users/damifiance/workspace/AI-paper-reader/frontend && npx tsc --noEmit` passes (no type errors)
    - `grep "secureStorage" frontend/src/lib/supabase.ts` confirms adapter is wired
    - `grep "onAuthStateChange" frontend/src/stores/authStore.ts` confirms listener is set up
    - `grep "supabase-js" frontend/package.json` confirms dependency installed
  </verify>
  <done>
    - @supabase/supabase-js installed in frontend
    - secureStorage adapter routes through IPC in Electron, falls back to localStorage in browser dev
    - Supabase client created with custom storage, autoRefreshToken, persistSession
    - Auth store provides initialize/signUp/signIn/signOut with loading states and friendly error translation
    - electron.d.ts updated with secureStore types
    - .env.example documents required env vars
  </done>
</task>

</tasks>

<verification>
- Electron secure store module loads without errors
- TypeScript compilation passes with no errors
- Supabase client is configured with custom secure storage (not localStorage)
- Auth store has all 4 actions (initialize, signUp, signIn, signOut)
- IPC handlers registered in main process
- contextBridge exposes secureStore in preload
</verification>

<success_criteria>
- All infrastructure files exist and TypeScript compiles cleanly
- Supabase client uses custom storage adapter (secureStorage.ts -> IPC -> safeStorage)
- Auth store is ready for UI consumption with proper loading/error states
- No direct localStorage usage for tokens
</success_criteria>

<output>
After completion, create `.planning/phases/04-supabase-foundation-and-email-auth/04-01-SUMMARY.md`
</output>
